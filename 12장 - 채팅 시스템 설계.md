# 12장 - 채팅 시스템 설계

## 1단계 : 문제 이해 및 설계 범위 확정
그룹 채팅인지, 1:1 채팅인지, 대규모 채팅에 따라 많이 다르니 잘 질문하자.
* 플랫폼
  * 앱, 웹
* 트래픽 규모
  * 일 5천만
* 그룹채팅
  * 인원제한 최대 100명
* 중요 기능
  * 1:1 채팅 + 그룹 채팅, 사용자 접속 상태, 텍스트만 가능
* 메시지 길이 제한
  * 10만자 이하
* 종단간 암호화
  * 제외
* 채팅 이력 보관
  * 영원히

## 2단계 : 개략적 설계안 제시 및 동의 구하기
* 보낼때 : HTTP 프로토콜로 전달
  * keep-alive 헤더를 사용하면 연결이 유지된다.
  * TCP 핸드 셰이크 횟수를 줄여준다.
* 받을때 : 폴링, 롱폴링, 웹 소켓 기법이 있다.

### 폴링
주기적으로 서버에 메시지가 있는지 확인 한다.
일부 불필요한 서버 호출 낭비가 있다.
![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image.png)<!-- {"width":411} -->

### 롱 폴링
새 메세지가 있을때 까지 (타임아웃될 때 까지) 연결을 유지한다.
![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%202.png)<!-- {"width":488} -->
* 약점
  * 메시지를 받은 서버는, 롱폴링 연결을 가지고 있지 않은 서버 일 수 있다.
  * 서버 입장에서는, 클라이언트가 연결을 해제했는지 모른다.
  * 메시지를 많이 받지 않는 모바일에서도, 타임아웃하면 재연결하는 비효율

### 웹 소켓
![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%203.png)<!-- {"width":592} -->
* 한번 맺어진 연결은 영구적, 양방향
* 처음엔 HTTP 연결, 핸드셰이크 절차 이후 웹소켓 연결
* 서버는 클라에 비동기적으로 전송 가능해짐
* 방화벽 있어도 ok, 일반적인 80이나 443 포트 그대로 씀

### 개략적 설계
* 무상태 서비스 : (로그인, 회원가입 등) HTTP 연결
* 상태유지 서비스 : 다른 서버로 연결 변경 안함
  * 서비스 탐색 서비스는 특정 서버로 몰리지 않게 해야함
* 3자 서비스 연동 : 푸시 알림
  ![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%204.png)<!-- {"width":447} -->

#### 규모 확장성
![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%205.png)<!-- {"width":569} -->
* 채팅 서버 : 클라이언트 메시지 중계
* 접속 상태 서버 : 사용자 접속 여부
* API 서버 : 회원가입 로그인 등 기본 기능들
* 알림 서버 : 푸시 전송
* 키 값 저장소 : 채팅 이력 보관

#### 저장소
* 관계형 vs NoSQL 고민 필요
  * 데이터 유형과 읽기/쓰기 연산의 패턴 파악으로 판단
* 채팅 데이터 특성
  * 일반적 데이터 : 사용자 프로파일, 설정, 친구 목록
    * 안정성 보장, 관계형 데이터에 보관 (확장성을 위해 다중화, 샤딩 고려)
  * 채팅 이력
    * 데이터의 양은 엄청나다.
    * 빈번하게 사용되는 데이터는 최근에 주고받은 메시지
    * 단, 검색이나 멘션되거나, 특정 메시지로 점프하는 경우도 있음
    * 1:1 채팅 앱의 경우 읽기:쓰기 비율은 1:1 정도다.
    * 본 설계안은 키-값 저장소를 추천한다.
* 키-값 저장소
  * 접근 시간이 낮다
  * 관계형은 롱 테일 (long tail) 에 해당하는 부분을 잘 처리하지 못함
    * 인덱스가 커지면 무작위 접근 비용이 늘어남
    * (일반적인 페이징 로직으로, 감당이 안되었던 기억)
  * 페이스북은 HBase, 디스코드는 Cassandra 사용

#### 데이터 모델링
* message
  * message_id - 메시지 순서를 정하는 역할도 담당
  * message_from
  * message_to
  * content
  * created_at
  * **PK (message_id)**
* group_message
  * channel_id - 파티션 키로도 사용할 것 (모든 질의는 특정 채널 대상)
  * message_id
  * message_to
  * content
  * **PK (channel_id, message_id)**

#### 메시지 ID
* message_id 값은 고유
* ID 값은 정렬 가능하게, 시간순서와 일치하게, 새로운 ID는 전보다 크게
* 구현방법
  * auto_increment - RDBMS 만 지원하는 문제
  * 스노우 플레이크 - 몇비트는 시간.. 몇비트는 일련번호..
  * 지역적 순서 번호 생성기 (필자 추천)
    * ID의 유일성은 같은 그룹 (채널, 1:1 세션) 안에서만 보증하면 되서 쉬움


## 3단계 : 상세 설계

### 서비스 탐색
* 클라이언트 에게 적절한 서버 분배
  * 클라이언트 위치, 서버의 용량으로 판단 할 수 있겠다.
  * Zookeeper 같은 것도 있다.
    * 모든 채팅 서버를 여기 등록시켜 두고
    * 클라이언트가 접속을 시도하면 최적의 서버 골라주기
      ![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%206.png)<!-- {"width":447} -->

### 메시지 흐름

#### 1:1 채팅 메시지 처리 흐름
![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%207.png)<!-- {"width":474} -->
1. 사용자 A가 채팅 서버 1로 전송
2. 채팅 서버 1은 메시지 ID 결정
3. 채팅 서버 1은 메시지 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. 사용자 B가 접속중이면 B가 접속중인 채팅서버로 전송
   * 접속중이 아니라면 푸시로 전송
6. 채팅 서버 2는 사용자 B에게 전송, (웹소켓 연결이 있는 서버)

#### 여러 단말 사이의 메시지 동기화
* cur_max_message_id 변수 : 해당 단말에서 관측된 가장 최신 ID
  * 저장소에 보관된 메시지가 cur_max_message_id 보다 크면 새 메시지로 판별
    ![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%208.png)<!-- {"width":520} -->

#### 소규모 그룹 채팅 메시지 흐름
* 사용자 A가 그룹 채팅에 메세지를 보냄
* 사용자 B와 C의 메시지 동기화 큐 (=할당받은 수신함) 에 복사됨
* 소규모에 적합함
  * 메시지를 수신자 별로 복사해서 큐에 넣는 작업 비용
    ![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%209.png)<!-- {"width":482} -->

##### 접속상태 표시
* 사용자 로그인
  * 웹소켓 연결이 맺어지면 last_active_at 보관, 접속중으로 표시
* 사용자 로그아웃
  * 사용자 로그아웃시 상태 offline 으로 변경

##### 접속 장애 
* 짧은 시간 연결이 끊어졌다 복구되는 경우는 흔하다
* 박동 (heartbeat) 검사로 문제 해결 방법
  * 온라인 상태의 클라이언트가 주기적으로 heartbeat 보냄
  * x 초 이내 계속 받으면 온라인, 못받으면 오프라인
    ![](12%EC%9E%A5%20-%20%EC%B1%84%ED%8C%85%20%EC%8B%9C%EC%8A%A4%ED%85%9C%20%EC%84%A4%EA%B3%84/image%2010.png)<!-- {"width":506} -->

##### 상태 정보의 전송
* 사용자 A 의 친구들은 사용자 A 의 상태를 어떻게 알까?
* 발행-구독(pub-sub) 모델 사용
  * 친구관계 마다 채널 두기
    * 사용자 A의 접속 상태가 변경되면?
    * 3 개 채널에 발행
      * A-B
      * A-C
      * A-D
    * 사용자 B,C,D 는 구독
  * 소규모에 적합한 방법임 (채널을 너무 많이 쓴다)
    * 대규모는 사용자가 입장하는 순간에만 읽기, 수동으로 유도하자


#대규모시스템설계기초
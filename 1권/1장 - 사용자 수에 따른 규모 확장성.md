# 1장 - 사용자 수에 따른 규모 확장성
* 한명의 사용자를 지원하는 시스템에서 시작, 최종적으로 몇백만 사용자를 지원하는 시스템 설계
## 단일서버
* 웹, 앱, 데이터베이스, 캐시 등이 전부 한 대에서 실행
  ![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%204.png)
  1. DNS
     1. 도메인 이름으로 웹사이트에 접속
  2. DNS에 질의하여 IP 주소로 변환
     1. DNS는 보통 제 3 사업자 (third party)가 제공하는 유료 서비스
     2. 조회 결과로 IP 주소 반환 (15.125.23.214)
  3. 해당 IP 주소로 HTTP 요청이 전달
  4. 서버는 HTML이나 JSON형태의 응답 반환
## 데이터베이스
* 전통 관계형 데이터베이스
  * Mysql, 오라클, PostgreSQL
  * 열, 칼럼으로 표현
  * 관계에 따라 조인 가능
  * Case)
    * 대부분의 경우 최선
* 비 관계형 데이터베이스
  * CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB
  * 다시 네 부류로 나눌 수 있음
    * 키-값 저장소
    * 그래프 저장소
    * 칼럼 저장소
    * 문서 저장소
  * Case)
    * 아주 낮은 응답지연 시간
    * 비정형 데이터
    * JSON,YAML,XML 을 직렬화/역직렬화만 하면 됨
    * 아주 많은 양의 데이터 저장

>  본인의 경우 다형성 목록 API 를 구현 목적으로 최근 DocumentDB 로 개발 해 보는중
> 유사 예시) 네이버 알림탭
> nullable 을 보장해 주지 않아서 생겼던 문제들
> ![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image.png)

## 수직적 규모 확장 vs 수평적 규모 확장
* 수직적 규모 확장 (scale up)
  * 서버에 고사양 자원을 추가하는 행위 (CPU, RAM)
  * 장점
    * 서버로 유입되는 트래픽의 양이 적을때, 단순함
  * 단점
    * 한대의 서버에 무한대로 증설할 방법이 없다
    * 자동복구(failover) 다중화(re-dundancy) 방안을 제시하지 않음
    * 장애가 발생하면 웹사이트/앱 중단됨
* 수평적 규모 확장 (scale out)
  * 더 많은 서버를 추가하여 성능을 개선하는 행위
  * 장점
    * 수식적 규모 확장의 단점 해결
    * 단일 서버의 문제 - 웹사이트 바로 연결, 서버 다운시 연결 불가
      * 로드밸런서 도입이 최선

### 로드밸런서

![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%203.png)

* 사용자는 공개 IP 주소로 접속
  * 웹서버는 클라이언트 접속을 직접 처리하지 않음
* 서버간 통신에는 사설 IP 주소 이용
* 웹서버를 추가하면 장애를 자동복구하지 못하는 문제 해결
  * 서버 1이 다운되면 서버 2로 전송
  * 트래픽이 증가하면 많은 서버 추기
* 데이터 계층의 다중화는 아직 이루어지지 않았다.

### 데이터베이스 자동화
* 많은 데이터베이스 제품이 다중화를 지원함 : master-slave 방식
* 쓰기연산은 마스터
  * insert, delete, update 등은 주 데이터베이스에만 전달 되어야함
* 대부분은 읽기 연산의 비중이 훨씬 높다
  * 통상 부데이터베이스의 수가 많다
* 다중화의 장점
  * 성능 : 읽기 연산의 분산, 병렬로 처리되는 질의 수가 늘어남
  * 안정성 : 지역적으로 일부가 파괴되어도 데이터는 보존
  * 가용성 : 하나의 DB가 장애여도 다른 서버로 서비스 지속 가능
* 장애상황
  * 부 서버 한대일때 다운
    * 한시적으로 주 DB로 전달
    * 즉시 새로운 부 DB가 대체
  * 주 서버 다운
    * 새로운 부 서버가 새로운 주 서버
    * 부서버가 최신이 아닐 수 있음 -> 복구 스크립트
      * 다중마스터나 원형 다중화 구성도 있으나 복잡함

### 개선된 설계안
![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%202.png)
* DNS -> 로드밸런서 -> 공개 IP 받음
* 해당 IP -> 로드밸런서
* HTTP 요청은 서버 1 OR 서버 2
* 웹서버 -> 부 데이터 서버 읽기
* 변경 연산 -> 주 데이터베이스

> 응답시간은 개선할 방법 - 캐시와 CDN 붙이기

## 캐시
* 캐시 계층 : 데이터가 잠시 보관되는 곳 (성능 개선, DB 부하 줄임, 캐시만 확장 가능)
* 다음은 읽기 주도형 캐시 전략 (read-through caching strategy)
  * 액세스 패턴에 따라 맞는 캐시 전략을 선택해야 함
    ![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%205.png)

### 유의할 점
* 고려해볼만한 케이스는 갱신은 자주 X 참조는 자주 O
* 영속적인 데이터 X 휘발됨
* 만료기한은 너무 짧으면 DB를 자주 읽음, 너무 길면 원본과 차이가 남
* 원본 갱신 연산과 캐시 갱신 연산이 단일 트랜잭션이 아니면 일관성(consistency) 깨짐 고민 필요
* 장애 대처 방법, 캐시가 한대면 SPOF 가 될 수있음, 분산해야함
* 캐시 메모리 크기 : 너무 작으면 밀려난다 (eviction) 과할당 하는 방법도 있음
* 데이터 방출 정책 : 캐시가 꽉차면 기존 데이터를 내보내는 방법
  * 가장 많이 쓰는 방법은 LRU (마지막 사용 시점이 가장 오래된 데이터를 내보내는 정책)

## CDN
* 정적 캐싱 : 정적 콘텐츠를 전송하는데 쓰이는, 이미지, 비디오, CSS, 자바스크립트 캐싱
* 동적 캐싱 : 요청경로, 쿼리, 쿠키, 헤더에 따라 캐싱
* 가장 가까운 CDN 서버가 정적 콘텐츠 전달, 멀주록 천처히 로드됨

![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%206.png)

* 이미지 URL 접근 -> 도메인은 CDN 이 제공
* CDN 서버의 캐시에 없는 이미지 -> 원본 서버에 요청 (웹서버 or S3)
* 원본 서버 -> 파일을 CDN에 빈환 -> TTL 값이 들어 있다
* 파일 캐시 -> 사용자에게 반환 -> 이미지는 TTL 값 까지 캐시
* 같은 이미지에 대한 요청을 다른 사용자가 요청
* 만료되지 않았으면 캐시를 통해 처리

### CDN 고려점
* 비용 : 데이터 전송양에 따라 요금, 자주 사용되지 않으면 빼는걸 고려
* 적절한 만료 시한 설정: 시의성이 중요하면 만료시점 잘 정하기
* CDN 장애 대처 : CDN 이 죽었을때 클라이언트 핸들링 방안 -> 원본 서버 요청 등
* 무효화 방법 : 만료되지 않은 콘텐츠 제거 (CDN 제공 API, 오브젝트 버저닝 등)


* 정적 콘텐츠는 CDN 제공, 웹서버가 더 나은 성능
* 캐시가 DB 부하 줄여줌

## 무상태 웹 계층
* 웹을 수평적으로 확장하는 방법
* 상태 정보 (세션) 을 웹에서 제거 해야함
* 세션 -> 관계형 DB나 NoSQL 과 같은 지속성 저장소에 보관
* 이렇게 구성하면 무상태 웹 계층

### 상태 정보 의존적인 아키텍처

[이미지]

* 서버가 클라이언트 정보(상태)를 유지하여 요청들 사이에 공유되게 만듬
* 사용자 A를 인증하기 위한 HTTP 요청은 반드시 서버 1로 전송 되어야 함
* 로드밸런서를 고정 세션 (sticky session) 으로 구성 해야함 - 로드밸런서 부담

### 무상태 아키텍처

![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%207.png)

* 어떤 웹서버로도 전달될 수 있다.
* 상태 정보가 필요한 경우 공유 저장소로부터 데이터를 가져온다.
* 단순하고, 안정적이며, 규모 확장이 쉽다.

![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%208.png)

* 기존 설계에서 무상태 웹계층을 갖도록 변경한 결과이다.
* 공유 저장소는 Redis/MemCached 와 같은 캐시 시스템, NoSQL 일 수 있음
  * 필자가 NoSQL 을 사용한 이유 : 규모 확장이 간편해서

### 데이터 센터
* 두 개의 데이터 센터를 이용하는 사례 (보통 가까운 데이터 센터 -> 지리적 라우팅)
* geoDNS -> 도메인 이름을 어떤 IP 주소로 변환할지 결정
  * x% 사용자는 Us-East, 나머지는 Us-West 센터

[그림 1-15]

* 심각한 장애가 발생한 경우 -> 장애가 없는 데이터 센터 100% 트래픽
* 기술적 난제
  * 트래픽 우회 : GeoDNS
  * 데이터 동기화 : 우회된 센터에는 없는 데이터 (여러 센터에 다중화? 어떻게?)
  * 테스트와 배포 : 여러 위치에서 테스트 해보기, 배포 도구를 여러 센터에 설치
* 시스템을 더 큰 규모로 확장 하려면? -> 독립적 확장을 우한 컴포넌트 분리 -> 메세지 큐
  ![](1%EC%9E%A5%20-%20%EC%82%AC%EC%9A%A9%EC%9E%90%20%EC%88%98%EC%97%90%20%EB%94%B0%EB%A5%B8%20%EA%B7%9C%EB%AA%A8%20%ED%99%95%EC%9E%A5%EC%84%B1/image%209.png)
## 메시지 큐
* 메시지의 무손실 보장, 비동기 통신 컴포넌트
* producer 또는 publisher 라고 불리는 입력 서비스가 메세지 publish
* 구독자 (consumer) 가 메시지를 받아 그에 맞는 동작 수행
* 서비스간 결합이 느슨해져서, 규모 확장성 보장 구성에 좋다.
* 사용예) 사진 보정 어플리케이션

## 로그, 메트릭 그리고 자동화
* 로그 : 에러 로그 모니터링
* 매트릭 
  * 호스트 단위 메트릭 (CPU, 메모리, 디스크 I/O)
  * 종합 메트릭 : 데이터베이스 계층 성능, 캐시 계층 성능
  * 핵심 비즈니스 매트릭 : DAU, 수익, 재방문
* 자동화 : 지속적 통합, 빌드,테스트,배포도구 자동화

* 메세지큐를 이용해 느슨한 결합
* 로그, 모니터링, 메트릭, 자동화 추가

## 데이터베이스 규모 확장
* 수직적 확장 : 스케일업, 고성능의 자원 (CPU,RAM 디스크)
  * 스택오버플로우는 한대의 마스터 디비로 처리
  * 약점
    * 하드웨어의 한계로 CPU,RAM 무한 증설 불가
    * SPOF 위험성
    * 비용
* 수평적 확장
  * 데이터베이스를 샤드로 분할
  * [그림 1-21] 샤딩 (user_id % 4) 해시 함수 -> 보관 샤드 지정
  * 중요 포인트 : 샤딩키(파티션 키) 지정
  * 단점
    * 데이터의 재 샤딩
    * 유명인사 문제 : 유명 연예인이 한 샤드에 몰리면? -> 해당 샤드만 read 연산
      * 트위터 아키텍처 유투브를 봤을때 기억상..
      * 트위터 홈은 팔로우한 유저가 글을쓰면, 팔로워들의 home 테이블에 쌓이는 구조
      * 유명인이 글을 쓸때는 이를 따르지 않고 -> (home 테이블 + 캐싱된 유명인사 글) merge 했던것 같다
    * 조인과 비정규화
      * 여러 샤드에 걸친 데이터 조인이 어려워진다.
      * 비정규화 OR 하나의 테이블에서 질의가 수행될 수 있도록 하는 것.
* 전회사는 샤딩을 쓰는 팀은 없었고, 읽기가 많은 팀 (상품목록) 앞단은 NoSQL 로 처리하신것만 본듯..



#대규모시스템설계기초
# 6장 - 키-값 저장소 설계
## 개요
* 비 관계형 데이터베이스이다.
* 저장되는 값은 고유 식별자로 키를 가져야 한다. (키-값 쌍)
* 성능상의 이유로 키는 짧을수록 좋다.
  * 일반 텍스트 키 : "last_logged_in_at"
  * 해시 키 : 253DDEC4
* 값은 문자열, 리스트, 객체 일 수 있다.
* 저장소는 다이나모, memcached, redis 같은 것들이 있다.
* put(key, value), get(key) 연산을 지원하는 저장소를 설계해보자.

## 문제 이해 및 설계 범위 확정
* 키-값 쌍의 크기는 10KB 이하
* 큰 데이터 저장 가능
* 높은 가용성 제공 
* 높은 규모 확장성 제공 
* 데이터 일관성 수준 조정 가능
* 짧은 응답 지연시간

## 단일 서버 키-값 저장소
* 한대로 설계하는건 쉽다
* 가장 직관적인 방법은 키-값 쌍 전부를 메모리에 해시 테이블로 저장하는것
* 모든 데이터를 메모리 안에 두는 것이 불가능하다는 약점
* 해결법 : 데이터 압축, 자주쓰이는 데이터만 메모리에 저장
* 이렇게 개선해도 단일 서버로 어려운 상황 -> 분산 키-값 저장소

## 분산 키-값 저장소
* 분산 해시테이블이라고도 불린다.
* 분산 시스템 설계에는 CAP 정리를 이해해야 함

## CAP 정리
CAP 정리는 이들 가운데 어떤 두가지를 충족하려면 나머지 하나는 희생되어야 한다는것
* 일관성(consistency)
  * 모든 클라이언트는 어떤 노드에 접속했느냐 관계 없이
  * **언제나 같은 데이터**를 보게 되어야 한다.
* 가용성(avaliability)
  * 일부 노드에 장애가 발생하더라도 **항상 응답**을 받을 수 있어야 한다.
* 파티션 감내성(partition tolerance)
  * 두 노드 사이에 통신 장애가 발생(=파티션) 하였어도 시스템은 계속 동작하여야 한다.

어느 두가지를 만족하는지에 따라 분류됨
* CA 시스템 : 일관성, 파티션 감내 - 가용성 희생
* AP 시스템 : 가용성과 파티션 감내 - 일관성 희생
* CA 시스템 : 일관성과 가용성 - 파티션 감내 희생 
  * (네트워크 장애는 피할수 없음, 실세계에선 존재하지 않는다)

### 이상적 상태 (불가)
* 세대의 복제노드 n1, n2, n3에 데이터를 복제하여 보관하는 상황 가정
* 이상적 환경이라면 네트워크 파티션이 절대로 일어나지 않을 것이다.
* n1에 기록되는 데이터는 n2, n3에 복제된다. (일관성, 가용성도 만족됨)
  ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image.png)<!-- {"width":308} -->

### 실세계의 분산 시스템
* 파티션 문제를 피할 수 없음, 파티션 문제가 발생하면 일관성과 가용성중 선택 해야함
* n3에 장애나면 n1,n2 와 통신할 수 없는 상황
* n1, n2에 기록한 데이터는 n3에 전달되지 않는다.
* n3에 기록되었고 n1, n2로 전달되지 않은 데이터가 있다면 n1,n2는 오래된 사본을 갖고 있을 것이다.
  ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2023.png)<!-- {"width":334} -->
* 가용성 대신 **일관성**을 선택한다면? (CP시스템)
  * n1과 n2에 대한 쓰기 연산을 중단 시킴 -> 가용성 깨짐
  * 은행권 시스템에 적합. 일관성을 양보하지 않는다.
  * 상황이 해결될 때까지는 오류를 반환해야 한다.
* 일관성 대신 **가용성**을 선택한다면? (AP시스템)
  * n1,n2는계속 읽기 연산을 허용해야한다.
    * n3 데이터가 반영되지 않은 낡은 데이터를 반환할 수 있다. -> 일관성 깨짐
  * n1,n2는 쓰기 연산을 허용해야한다.
    * 문제가 해결되면 새 데이터를 n3에 전송한다.

## 시스템 컴포넌트
키-값 저장소 구현에 사용될 핵심 컴포넌트와 기술
* 데이터 파티션
* 데이터 다중화
* 일관성
* 일관성 불일치 해소
* 장애 처리
* 시스템 아키텍처 다이어그램
* 쓰기 경로
* 읽기 경로

### 데이터 파티션
전체 데이터를 한 대 서버에 넣는것은 불가능
* 데이터를 여러 서버에 고르게 분산할 수 있는가
* 노드가 추가되거나 삭제될 때 데이터 이동을 최소화 할 수 있는가
  * 5장에서 살펴본 안정해시 사용!

### 데이터 다중화
* 높은 가용성과 안정성을 위해, 데이터를 N개 서버에 **비동기적으로 다중화**할 필요가 있다.
* 시계방향으로 링을 순회하면서 만나는 첫 N개 서버에 데이터 사본을 보관한다. (안정해시)
* 가상노드를 사용한다면 실제 물리 서버의 개수가 N보다 작아질 수 있다.
  * 같은 물리서버를 중복 선택할 위험이 있다.
    * 같은 데이터 센터에 속한 노드는 정전, 네트워크 이슈, 자연재해 문제를 동시에 겪을 가능성

### 데이터 일관성
* 여러 노드에 다중화된 데이터는 적절히 동기화 되어야 한다.
* 정족수 합의 (Quorum Consensus) 프로토콜을 사용하면 읽기/쓰기 연산 모두에 일관성을 보장할 수 있다.
  * N=사본개수
  * W=쓰기연산에 대한 정족수
    * W개의 서버로부터 쓰기 연산이 성공해야함
  * R=읽기연산에 대한 정족수
    * R개의 서버로부터 응다블 받아야함

N=3인경우의 예시
![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2021.png)<!-- {"width":416} -->

* 중재자 (coordinator)
  * 클라이언트와 노드 사이의 프록시 역할
  * W=1 이면 최소 한대 쓰기 성공
    * s1에서 성공이면 s0, s2 응답 안받아도 됨
  * W나 R의 값이 1보다 크면, 일관성 수준 향상, 성능 저하
  * W+R>N인 경우에는 강한 일관성이 보장됨

#### 면접시에는 N,W,R 을 어떻게 정할까?
* R=1, W=N: 빠른 읽기 연산 시스템
* W=1, R=N: 빠른 쓰기 연산 시스템
* W+R>N: 강한 일관성 보장
* W+R<=N:강한 일관성 보장되지 않음

### 일관성 모델
* 강한 일관성 : 모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다.
  * 클라이언트는 절대로!! 낡은 데이터를 보지 못하게 한다.
  * 모든 사본에 쓰기 연산의 결과가 반영될때까지, 해당 데이터 읽기/쓰기 금지
    * 고가용성에는 적합하지 않음
* 약한 일관성 : 가장 최근에 갱신된 결과를 반환하지 못할 수 있다.
* 최종 일관성 : 약한 일관성의 한종류, 갱신 결과가 결국에는 모든 사본에 반영되는 모델이다.
  * 일관성이 깨진경우, 클라이언트가 해결하는 방법

#### 비 일관성 해소 기법: 데이터 버저닝
name 이 john 인 데이터 n1, n2 복제된 상태 가정
![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%205.png)
* 버1은 johnSanFrancisco, 서버2는 johnNewYork 각각 동시에 변경
* 충돌하는 두 값을 갖게 됨
* 각각 버전 v1, v2로 가정
  ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%204.png)
* 벡터 시계는 이런 충돌 문제를 푸는데 보편적으로 사용되는 기술이다.
* {서버, 버전}의 순서쌍을 데이터에 매단 것이다.
  * 어떤 버전이 선행 버전인지, 후행 버전인지 판별
* 백터 시계 표현 방법
  * D([S1, v1], [S2, v2] ... [Sn, vn])
  * D는 데이터, v는 버전 카운터, S는 서버번호
* 데이터 D를 서버 Sn에 기록하면?
  * 시스템은 아래 작업 가운데 하나를 수행해야 함
    * [Sn, Vn]이 있으면 Vn 증가
    * 그렇지 않으면 새 항목 [Sn, 1]을 만들기
      ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2024.png)<!-- {"width":377} -->
* 충돌은 어떻게 파악하지?
  * 모든 구성요소의 값이 X에 포함된 모든 구성요소 값보다 같거나 큰지만 보면 된다.
    * D([s0, 1], [s1, 1]) 은 D([s0, 1], [s1, 2]) 의 이전버전이다.
* 단점
  * 충돌 감지 및 해소 로직이 클라이언트에 들어가, 구현이 복잡해짐
  * 순서쌍이 굉장히 빨리 늘어남, 임계치 이상으로 길어지면 제거해야함
    * 그러면 충돌 해소의 효율성이 낮아지게 되지만, 다이나모에선 그런 일이 없었다함
* 장애 감지
  * 모든 노드 사이에 헬스체크 멀티캐스팅 채널을 구축해야 서버 장애를 감지하기 손쉬움
  * 서버가 많을 때는 비효율적
  * 가십 프로토콜 같은 분산형 장애 감지 솔루션을 채택하는 것이 낫다
    * 각 노드는 멤버십 목록 유지
    * 각 노드는 주기적으로 자신의 박동 카운터를 증가
    * 각 노드는 무작위로 선정된 노드들에게 주기적으로 자기 박동 카운터 목록을 보내줌
    * 박동 카운터 목록을 받은 노드는 멤버십 목록을 최신값으로 갱신
    * 어떤 멤버의 박동 카운터 값이 갱신되지 않으면 장애 상태로 간주
      ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2017.png)

#### 일시적 장애 처리
* 엄격한 정족수 : 읽기와 쓰기 금지
* 느슨한 정족수 : 가용성을 높임, 장애 상태인 서버는 무시
  * 쓰기 연산을 수행할 W개의 건강한 서버
  * 읽기 연산을 수행할 R개의 건강한 서버를 고름
  * 장애 서버의 역할은 다른 서버가 잠시 맡아 처리
    * 그동한 발견된 변경사항은 해당 서버가 복구 되었을때 일괄 반영
    * 임시 처리한 쓰기 연산 서버는 단서(hint)를 남겨둠
      * 단서 후 임시 위탁 기법 (hinted handoff)

#### 영구 장애 처리
* 반-엔트로피 프로토콜을 구현하여 사본들을 동기화
  * 머클 트리 사용
    * 각 노드에 그 자식 노드들에 보관된 값의 해시
    * 또는 자식 노드들의 레이블로부터 계산된 해시값을 레이블로 붙여두는 트리
    * 대규모 자료 구조의 내용을 효과적이면서 보안상 안전한 방법으로 검증
    * ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%208.png)
    * 루트노드가 일치하면 같은데이터, 다르면 왼쪽/오른쪽 자식노드 비교해가며 필요한 데이터만 동기화

### 시스템 아키텍처 다이어그램
* 클라이언트는 키-값 저장소가 제공하는 단순한 API get, put 으로 통신
* 중재자는 프락시 역할을 하는 노드
* 노드는 안정 해시의 해시링 위에서 분포
  ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2010.png)

* 노드를 자동으로 추가/삭제할 수 있도록 시스템은 완전히 분산됨
* 데이터는 여러 노드에 다중화됨
* 모든 노드가 같은 책임 (아래 기능), SPOF는 존재하지 않음
  * ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2018.png)<!-- {"width":285} -->
### 쓰기 경로
쓰기 요청이 특정 노드에 전달되면 일어나는 일 (카산드라 사례)
* 쓰기 요청이 커밋 로그 파일에 기록
* 데이터가 메모리에 캐시
* 메모리 캐시가 임계치에 도달하면 디스크 SSTable에 기록
  * SStable : Sorted-String Table (키,값 순서쌍 정렬된 리스트 형태로 관리하는 테이블)
    ![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2011.png)<!-- {"width":420} -->

### 읽기 경로
![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2012.png)
* 데이터가 메모리에 있으면 바로 반환, 없으면 2로 간다
* 데이터가 메모리에 없으면 블룸 필터 검사
* 블룸 필터를 통해 어떤 SsTable에 키가 보관되어 있는지 확인
* SSTable 에서 데이터를 가져온다
* 해당 데이터를클라이언트에게 반환한다

## 요약
![](6%EC%9E%A5%20-%20%ED%82%A4-%EA%B0%92%20%EC%A0%80%EC%9E%A5%EC%86%8C%20%EC%84%A4%EA%B3%84/image%2015.png)

#대규모시스템설계기초